/**
 * ANSA Brasil Website Security Test Suite
 * 
 * Run with: npx ts-node security-tests/pentest.ts [target-url]
 * Default target: http://localhost:4545
 * 
 * Tests cover:
 * - Path Traversal
 * - Cross-Site Scripting (XSS) vectors
 * - Security Headers
 * - Information Disclosure
 * - Input Validation
 * - CORS Configuration
 * - Rate Limiting
 * - Directory Traversal
 */

const BASE_URL = process.argv[2] || 'http://localhost:4545';
const API_URL = process.env.API_URL || 'http://localhost:3001';

interface TestResult {
  name: string;
  category: string;
  status: 'PASS' | 'FAIL' | 'WARN' | 'INFO';
  details: string;
  severity?: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
}

const results: TestResult[] = [];

function log(result: TestResult) {
  results.push(result);
  const icon = {
    PASS: '✓',
    FAIL: '✗',
    WARN: '⚠',
    INFO: 'ℹ',
  }[result.status];
  
  const color = {
    PASS: '\x1b[32m',
    FAIL: '\x1b[31m',
    WARN: '\x1b[33m',
    INFO: '\x1b[36m',
  }[result.status];
  
  console.log(`${color}${icon}\x1b[0m [${result.category}] ${result.name}`);
  if (result.status !== 'PASS') {
    console.log(`  └─ ${result.details}`);
    if (result.severity) {
      console.log(`  └─ Severity: ${result.severity}`);
    }
  }
}

async function testSecurityHeaders() {
  console.log('\n=== Security Headers Tests ===\n');
  
  try {
    const response = await fetch(BASE_URL);
    const headers = response.headers;
    
    // X-Content-Type-Options
    const xContentType = headers.get('x-content-type-options');
    log({
      name: 'X-Content-Type-Options Header',
      category: 'Headers',
      status: xContentType === 'nosniff' ? 'PASS' : 'WARN',
      details: xContentType ? `Value: ${xContentType}` : 'Header not set. Recommend adding: nosniff',
      severity: 'LOW',
    });
    
    // X-Frame-Options
    const xFrameOptions = headers.get('x-frame-options');
    log({
      name: 'X-Frame-Options Header (Clickjacking)',
      category: 'Headers',
      status: xFrameOptions ? 'PASS' : 'WARN',
      details: xFrameOptions ? `Value: ${xFrameOptions}` : 'Header not set. Recommend: DENY or SAMEORIGIN',
      severity: 'MEDIUM',
    });
    
    // Content-Security-Policy
    const csp = headers.get('content-security-policy');
    log({
      name: 'Content-Security-Policy Header',
      category: 'Headers',
      status: csp ? 'PASS' : 'WARN',
      details: csp ? `CSP configured` : 'No CSP header. Recommend implementing to prevent XSS.',
      severity: 'MEDIUM',
    });
    
    // Strict-Transport-Security
    const hsts = headers.get('strict-transport-security');
    log({
      name: 'Strict-Transport-Security (HSTS)',
      category: 'Headers',
      status: hsts ? 'PASS' : 'INFO',
      details: hsts ? `HSTS enabled` : 'HSTS not set. Configure on production with HTTPS.',
      severity: 'MEDIUM',
    });
    
    // X-XSS-Protection (legacy but still useful)
    const xssProtection = headers.get('x-xss-protection');
    log({
      name: 'X-XSS-Protection Header',
      category: 'Headers',
      status: xssProtection ? 'PASS' : 'INFO',
      details: xssProtection ? `Value: ${xssProtection}` : 'Header not set (modern browsers use CSP instead)',
    });
    
    // Referrer-Policy
    const referrer = headers.get('referrer-policy');
    log({
      name: 'Referrer-Policy Header',
      category: 'Headers',
      status: referrer ? 'PASS' : 'INFO',
      details: referrer ? `Value: ${referrer}` : 'Not set. Recommend: strict-origin-when-cross-origin',
    });
    
    // Permissions-Policy
    const permissions = headers.get('permissions-policy');
    log({
      name: 'Permissions-Policy Header',
      category: 'Headers',
      status: permissions ? 'PASS' : 'INFO',
      details: permissions ? `Configured` : 'Not set. Consider restricting browser features.',
    });

  } catch (error) {
    log({
      name: 'Security Headers Test',
      category: 'Headers',
      status: 'FAIL',
      details: `Could not connect to ${BASE_URL}: ${error}`,
      severity: 'HIGH',
    });
  }
}

async function testPathTraversal() {
  console.log('\n=== Path Traversal Tests ===\n');
  
  const traversalPayloads = [
    '../../../etc/passwd',
    '..%2F..%2F..%2Fetc%2Fpasswd',
    '....//....//....//etc/passwd',
    '%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd',
    '..\\..\\..\\windows\\system32\\config\\sam',
    '..%5c..%5c..%5cwindows%5csystem32%5cconfig%5csam',
  ];
  
  const endpoints = [
    '/pt/projects/',
    '/en/projects/',
    '/pt/categories/',
    '/pt/',
  ];
  
  for (const endpoint of endpoints) {
    for (const payload of traversalPayloads) {
      try {
        const url = `${BASE_URL}${endpoint}${encodeURIComponent(payload)}`;
        const response = await fetch(url);
        const text = await response.text();
        
        // Check for signs of successful traversal
        const vulnerableIndicators = [
          'root:',
          '[boot loader]',
          'SYSTEM',
          '/bin/bash',
        ];
        
        const isVulnerable = vulnerableIndicators.some(indicator => 
          text.toLowerCase().includes(indicator.toLowerCase())
        );
        
        if (isVulnerable) {
          log({
            name: `Path Traversal: ${endpoint}`,
            category: 'Path Traversal',
            status: 'FAIL',
            details: `Vulnerable to: ${payload}`,
            severity: 'CRITICAL',
          });
          return; // Found vulnerability, no need to continue
        }
      } catch (error) {
        // Connection errors are expected for blocked requests
      }
    }
  }
  
  log({
    name: 'Path Traversal Protection',
    category: 'Path Traversal',
    status: 'PASS',
    details: 'No path traversal vulnerabilities detected',
  });
}

async function testXSS() {
  console.log('\n=== XSS Tests ===\n');
  
  const xssPayloads = [
    '<script>alert(1)</script>',
    '<img src=x onerror=alert(1)>',
    '"><script>alert(1)</script>',
    "'-alert(1)-'",
    '<svg onload=alert(1)>',
    'javascript:alert(1)',
    '<iframe src="javascript:alert(1)">',
    '<body onload=alert(1)>',
  ];
  
  // Test URL-based XSS
  for (const payload of xssPayloads) {
    try {
      const url = `${BASE_URL}/pt/projects/${encodeURIComponent(payload)}`;
      const response = await fetch(url);
      const text = await response.text();
      
      // Check if payload is reflected without encoding
      if (text.includes(payload) && !text.includes(encodeURIComponent(payload))) {
        log({
          name: 'Reflected XSS in URL',
          category: 'XSS',
          status: 'FAIL',
          details: `Payload reflected: ${payload.substring(0, 30)}...`,
          severity: 'HIGH',
        });
        break;
      }
    } catch (error) {
      // Expected for blocked requests
    }
  }
  
  log({
    name: 'URL-based XSS Protection',
    category: 'XSS',
    status: 'PASS',
    details: 'React/Next.js provides automatic XSS escaping',
  });
}

async function testDirectoryListing() {
  console.log('\n=== Directory Listing Tests ===\n');
  
  const directories = [
    '/uploads/',
    '/uploads/2024/',
    '/uploads/2025/',
    '/_next/',
    '/public/',
    '/.git/',
    '/.env',
    '/node_modules/',
    '/src/',
    '/api/',
  ];
  
  for (const dir of directories) {
    try {
      const response = await fetch(`${BASE_URL}${dir}`);
      const text = await response.text();
      
      // Check for directory listing indicators
      const listingIndicators = [
        'Index of',
        'Directory listing',
        '<title>Index of',
        'Parent Directory',
      ];
      
      const hasListing = listingIndicators.some(indicator => 
        text.includes(indicator)
      );
      
      if (hasListing) {
        log({
          name: `Directory Listing: ${dir}`,
          category: 'Information Disclosure',
          status: 'FAIL',
          details: 'Directory listing enabled',
          severity: 'MEDIUM',
        });
      }
      
      // Check for sensitive file exposure
      if (dir === '/.env' && response.status === 200) {
        log({
          name: 'Environment File Exposed',
          category: 'Information Disclosure',
          status: 'FAIL',
          details: '.env file is publicly accessible',
          severity: 'CRITICAL',
        });
      }
      
      if (dir === '/.git/' && response.status === 200) {
        log({
          name: 'Git Repository Exposed',
          category: 'Information Disclosure',
          status: 'FAIL',
          details: '.git directory is publicly accessible',
          severity: 'CRITICAL',
        });
      }
      
    } catch (error) {
      // Expected for blocked/non-existent paths
    }
  }
  
  log({
    name: 'Directory Listing Protection',
    category: 'Information Disclosure',
    status: 'PASS',
    details: 'No directory listings or sensitive files exposed',
  });
}

async function testErrorHandling() {
  console.log('\n=== Error Handling Tests ===\n');
  
  const errorTriggers = [
    '/nonexistent-page-12345',
    '/pt/projects/nonexistent-slug-99999',
    '/api/nonexistent',
    "/%00",
    '/..;/',
  ];
  
  for (const trigger of errorTriggers) {
    try {
      const response = await fetch(`${BASE_URL}${trigger}`);
      const text = await response.text();
      
      // Check for sensitive error information
      const sensitivePatterns = [
        /at\s+\w+\s+\([^)]+:\d+:\d+\)/g, // Stack traces
        /Error:\s+ENOENT/g,
        /Cannot\s+read\s+property/g,
        /undefined\s+is\s+not/g,
        /TypeError:/g,
        /ReferenceError:/g,
        /node_modules/g,
        /internal\/modules/g,
      ];
      
      for (const pattern of sensitivePatterns) {
        if (pattern.test(text)) {
          log({
            name: `Stack Trace Exposure: ${trigger}`,
            category: 'Information Disclosure',
            status: 'WARN',
            details: 'Server error details may be exposed to users',
            severity: 'LOW',
          });
          break;
        }
      }
    } catch (error) {
      // Expected for some error paths
    }
  }
  
  log({
    name: 'Error Handling',
    category: 'Information Disclosure',
    status: 'PASS',
    details: 'No sensitive error information exposed',
  });
}

async function testCORS() {
  console.log('\n=== CORS Configuration Tests ===\n');
  
  try {
    // Test API CORS
    const response = await fetch(`${API_URL}/health`, {
      method: 'OPTIONS',
      headers: {
        'Origin': 'https://evil-site.com',
        'Access-Control-Request-Method': 'POST',
      },
    });
    
    const allowOrigin = response.headers.get('access-control-allow-origin');
    
    if (allowOrigin === '*') {
      log({
        name: 'API CORS Configuration',
        category: 'CORS',
        status: 'WARN',
        details: 'CORS allows all origins (*). Consider restricting to specific domains.',
        severity: 'MEDIUM',
      });
    } else if (allowOrigin === 'https://evil-site.com') {
      log({
        name: 'API CORS Configuration',
        category: 'CORS',
        status: 'WARN',
        details: 'CORS reflects arbitrary origins. Potential security issue.',
        severity: 'MEDIUM',
      });
    } else {
      log({
        name: 'API CORS Configuration',
        category: 'CORS',
        status: 'PASS',
        details: allowOrigin ? `Restricted to: ${allowOrigin}` : 'CORS properly configured',
      });
    }
  } catch (error) {
    log({
      name: 'API CORS Test',
      category: 'CORS',
      status: 'INFO',
      details: `Could not reach API at ${API_URL}`,
    });
  }
}

async function testRateLimiting() {
  console.log('\n=== Rate Limiting Tests ===\n');
  
  const requestCount = 50;
  let successCount = 0;
  const startTime = Date.now();
  
  try {
    // Rapid requests to contact endpoint
    const promises = Array(requestCount).fill(null).map(() =>
      fetch(`${API_URL}/api/contact`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          name: 'Test',
          email: 'test@example.com',
          message: 'Rate limit test',
        }),
      }).catch(() => null)
    );
    
    const responses = await Promise.all(promises);
    successCount = responses.filter(r => r && r.status < 429).length;
    
    const duration = Date.now() - startTime;
    
    if (successCount === requestCount) {
      log({
        name: 'API Rate Limiting',
        category: 'DoS Protection',
        status: 'WARN',
        details: `${requestCount} requests in ${duration}ms all succeeded. No rate limiting detected.`,
        severity: 'MEDIUM',
      });
    } else {
      log({
        name: 'API Rate Limiting',
        category: 'DoS Protection',
        status: 'PASS',
        details: `Rate limiting active: ${successCount}/${requestCount} requests allowed`,
      });
    }
  } catch (error) {
    log({
      name: 'Rate Limiting Test',
      category: 'DoS Protection',
      status: 'INFO',
      details: `Could not reach API: ${error}`,
    });
  }
}

async function testInputValidation() {
  console.log('\n=== Input Validation Tests ===\n');
  
  const maliciousInputs = [
    { name: '', email: 'test@test.com', message: 'test' }, // Empty name
    { name: 'Test', email: 'invalid-email', message: 'test' }, // Invalid email
    { name: 'Test', email: 'test@test.com', message: '' }, // Empty message
    { name: 'A'.repeat(10000), email: 'test@test.com', message: 'test' }, // Very long name
    { name: '<script>alert(1)</script>', email: 'test@test.com', message: 'test' }, // XSS in name
    { name: 'Test', email: "'; DROP TABLE users; --", message: 'test' }, // SQL injection
  ];
  
  for (const input of maliciousInputs) {
    try {
      const response = await fetch(`${API_URL}/api/contact`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(input),
      });
      
      if (response.status === 200 && (input.name === '' || input.email === 'invalid-email' || input.message === '')) {
        log({
          name: 'Input Validation',
          category: 'Validation',
          status: 'WARN',
          details: `Invalid input accepted: ${JSON.stringify(input).substring(0, 50)}...`,
          severity: 'LOW',
        });
      }
    } catch (error) {
      // Expected for blocked requests
    }
  }
  
  log({
    name: 'Input Validation (Zod)',
    category: 'Validation',
    status: 'PASS',
    details: 'API uses Zod schema validation',
  });
}

async function testSSRF() {
  console.log('\n=== SSRF Tests ===\n');
  
  // Test if image loading can be abused
  // Next.js Image with hostname: '**' allows any remote image
  log({
    name: 'Next.js Image Remote Patterns',
    category: 'SSRF',
    status: 'WARN',
    details: 'next.config.ts allows images from any hostname (hostname: "**"). Consider restricting to known domains.',
    severity: 'LOW',
  });
}

async function testStaticAssets() {
  console.log('\n=== Static Assets Tests ===\n');
  
  const sensitiveFiles = [
    '/robots.txt',
    '/sitemap.xml',
    '/.well-known/security.txt',
    '/package.json',
    '/package-lock.json',
    '/tsconfig.json',
    '/next.config.ts',
    '/next.config.mjs',
  ];
  
  for (const file of sensitiveFiles) {
    try {
      const response = await fetch(`${BASE_URL}${file}`);
      
      if (response.status === 200) {
        const isSensitive = ['/package.json', '/package-lock.json', '/tsconfig.json', '/next.config'].some(
          f => file.includes(f)
        );
        
        if (isSensitive) {
          log({
            name: `Sensitive File Exposed: ${file}`,
            category: 'Information Disclosure',
            status: 'WARN',
            details: 'Configuration file publicly accessible',
            severity: 'LOW',
          });
        }
      }
    } catch (error) {
      // Expected for missing files
    }
  }
  
  log({
    name: 'Static Assets Security',
    category: 'Information Disclosure',
    status: 'PASS',
    details: 'No critical configuration files exposed',
  });
}

async function generateReport() {
  console.log('\n' + '='.repeat(60));
  console.log('SECURITY TEST REPORT');
  console.log('='.repeat(60));
  console.log(`Target: ${BASE_URL}`);
  console.log(`API: ${API_URL}`);
  console.log(`Date: ${new Date().toISOString()}`);
  console.log('='.repeat(60));
  
  const summary = {
    total: results.length,
    pass: results.filter(r => r.status === 'PASS').length,
    fail: results.filter(r => r.status === 'FAIL').length,
    warn: results.filter(r => r.status === 'WARN').length,
    info: results.filter(r => r.status === 'INFO').length,
  };
  
  console.log('\nSummary:');
  console.log(`  Total Tests: ${summary.total}`);
  console.log(`  \x1b[32mPassed: ${summary.pass}\x1b[0m`);
  console.log(`  \x1b[31mFailed: ${summary.fail}\x1b[0m`);
  console.log(`  \x1b[33mWarnings: ${summary.warn}\x1b[0m`);
  console.log(`  \x1b[36mInfo: ${summary.info}\x1b[0m`);
  
  const critical = results.filter(r => r.severity === 'CRITICAL');
  const high = results.filter(r => r.severity === 'HIGH');
  const medium = results.filter(r => r.severity === 'MEDIUM');
  
  if (critical.length > 0) {
    console.log('\n\x1b[31mCRITICAL ISSUES:\x1b[0m');
    critical.forEach(r => console.log(`  - ${r.name}: ${r.details}`));
  }
  
  if (high.length > 0) {
    console.log('\n\x1b[31mHIGH SEVERITY ISSUES:\x1b[0m');
    high.forEach(r => console.log(`  - ${r.name}: ${r.details}`));
  }
  
  if (medium.length > 0) {
    console.log('\n\x1b[33mMEDIUM SEVERITY ISSUES:\x1b[0m');
    medium.forEach(r => console.log(`  - ${r.name}: ${r.details}`));
  }
  
  console.log('\n' + '='.repeat(60));
  
  if (summary.fail > 0 || critical.length > 0) {
    console.log('\x1b[31mOVERALL: SECURITY ISSUES FOUND - DO NOT DEPLOY\x1b[0m');
    process.exit(1);
  } else if (summary.warn > 0) {
    console.log('\x1b[33mOVERALL: WARNINGS FOUND - REVIEW BEFORE DEPLOYMENT\x1b[0m');
  } else {
    console.log('\x1b[32mOVERALL: PASSED - READY FOR DEPLOYMENT\x1b[0m');
  }
}

async function main() {
  console.log('\n' + '='.repeat(60));
  console.log('ANSA BRASIL SECURITY PENETRATION TEST');
  console.log('='.repeat(60));
  console.log(`\nTarget URL: ${BASE_URL}`);
  console.log(`API URL: ${API_URL}\n`);
  
  await testSecurityHeaders();
  await testPathTraversal();
  await testXSS();
  await testDirectoryListing();
  await testErrorHandling();
  await testCORS();
  await testRateLimiting();
  await testInputValidation();
  await testSSRF();
  await testStaticAssets();
  
  await generateReport();
}

main().catch(console.error);

